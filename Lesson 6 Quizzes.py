##Exercise: Iterative Parsingdef count_tags(filename):    dict = {}    for event, elem in ET.iterparse(filename):        if elem.tag in dict:            dict[elem.tag] += 1        else:            dict[elem.tag] = 1    return dict##Exercise: Tag Typeslower = re.compile(r'^([a-z]|_)*$')lower_colon = re.compile(r'^([a-z]|_)*:([a-z]|_)*$')problemchars = re.compile(r'[=\+/&<>;\'"\?%#$@\,\. \t\r\n]')def key_type(element, keys):    if element.tag == "tag":        tag_key = element.attrib['k']        if lower.match(tag_key):  ## Hideously inelegant, but it works            keys['lower'] += 1                    elif lower_colon.match(tag_key):            keys['lower_colon'] += 1                    elif problemchars.search(tag_key):            keys['problemchars'] += 1        else:            keys['other'] += 1                return keys##Exercise: Exploring Usersdef process_map(filename):    users = set()    tags = ['node','way','relation']    for _, element in ET.iterparse(filename):        if element.tag in tags:            user = element.attrib['user']            users.update([(user)])    return users##Exercise: Improving Street Names# UPDATE THIS VARIABLEmapping = { "St": "Street",            "St.": "Street",            "Ave": "Avenue", # added            "Rd.": "Road" # added            }def update_name(name, mapping):    words = name.split(" ")    words[len(words)-1] = mapping[words[len(words)-1]]    sep = " "    name = sep.join(words)    return name##Preparing for Database	def shape_element(element):    node = {}    created = {}    address = {}    node_refs = []    if element.tag == "node" or element.tag == "way" :        node.update([("type",element.tag)])        lat = 0.        lon = 0.        #process key-value pairs        for key in element.attrib.keys():            if key in CREATED:                created.update([(key,element.attrib[key])])            elif key == "lat":                lat = float(element.attrib[key])            elif key == "lon":                lon = float(element.attrib[key])            else:                node.update([(key,element.attrib[key])])        # process second-level elements        for child in element:            if child.tag == "tag":                child_key = child.attrib["k"]                child_value = child.attrib["v"]                # check for problem characters in key                if type(problemchars.search(child_key)) != type(None):                    #print "problem chars", child_key                    continue                # process "addr:" key                elif child_key.find("addr:") == 0:                    addr_keys = child_key.split(":")                    if len(addr_keys) == 2:                        address.update([(addr_keys[1], child_value)])                else:                    node.update([(child_key, child_value)])            elif child.tag == "nd":                node_refs.append(child.attrib["ref"])        # wrap up        if lat != 0. and lon != 0.:            pos = [lat,lon]            node.update([("pos",pos)])        if len(address) > 0:            node.update([("address",address)])        if len(node_refs) > 0:            node.update([("node_refs",node_refs)])        node.update([("created",created)])        return node    else:        return None